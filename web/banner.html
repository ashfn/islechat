<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Banner Editor – isle.chat</title>
  <style>
    :root {
      --sand: #fef3e2;
      --sand-dark: #f4d9b8;
      --ocean: #1e90ff;
      --ocean-dark: #0059b3;
      --ocean-light: #87ceeb;
      --foam: #ffffff;
      --text-dark: #2c3e50;
      --text-light: rgba(44, 62, 80, 0.7);
      --shadow: rgba(0, 59, 179, 0.15);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 20px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: linear-gradient(180deg, #87ceeb 0%, #fef3e2 100%);
      min-height: 100vh;
      color: var(--text-dark);
    }
    .header {
      text-align: center;
      margin-bottom: 24px;
    }
    h1 {
      font-size: 1.8rem;
      margin: 0 0 8px;
      color: var(--ocean-dark);
      font-weight: 600;
    }
    .sub {
      font-size: 0.9rem;
      color: var(--text-light);
      margin-bottom: 0;
    }
    .layout {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      align-items: flex-start;
      justify-content: center;
      max-width: 1200px;
      margin: 0 auto;
    }
    .panel {
      background: var(--foam);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 8px 32px var(--shadow);
    }
    #pixelPanel {
      flex: 0 0 auto;
    }
    .panel-title {
      font-weight: 600;
      color: var(--ocean-dark);
      margin-bottom: 12px;
      font-size: 0.95rem;
    }
    #pixelCanvas {
      display: grid;
      grid-template-columns: repeat(40, 12px);
      grid-template-rows: repeat(40, 12px);
      gap: 1px;
      background: var(--ocean-light);
      border-radius: 8px;
      padding: 4px;
      cursor: crosshair;
      touch-action: none;
      box-shadow: inset 0 2px 4px rgba(0, 59, 179, 0.2);
    }
    .pixel {
      width: 12px;
      height: 12px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 2px;
      transition: all 0.1s ease;
    }
    .pixel.on {
      background: var(--ocean);
      box-shadow: 0 0 6px rgba(30, 144, 255, 0.4);
      transform: scale(0.95);
    }
    #rightPanel {
      flex: 1 1 300px;
      min-width: 300px;
      max-width: 520px;
    }
    fieldset {
      border-radius: 12px;
      border: 2px solid var(--sand-dark);
      margin-bottom: 16px;
      padding: 12px;
      background: rgba(254, 243, 226, 0.5);
    }
    legend {
      padding: 0 8px;
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--ocean-dark);
    }
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      font-size: 0.9rem;
    }
    button {
      background: var(--ocean);
      color: var(--foam);
      border: none;
      border-radius: 999px;
      padding: 8px 16px;
      cursor: pointer;
      font: inherit;
      font-weight: 500;
      transition: all 0.2s ease;
    }
    button:hover {
      background: var(--ocean-dark);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(30, 144, 255, 0.3);
    }
    button.secondary {
      background: var(--sand);
      color: var(--ocean-dark);
      border: 2px solid var(--sand-dark);
    }
    button.secondary:hover {
      background: var(--sand-dark);
      transform: translateY(-1px);
    }
    button:active {
      transform: translateY(0);
    }
    label {
      cursor: pointer;
    }
    #charCanvasWrapper {
      margin-top: 12px;
      border-radius: 12px;
      border: 2px solid var(--ocean-light);
      padding: 12px;
      background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(135,206,235,0.1));
      box-shadow: inset 0 2px 4px rgba(0, 59, 179, 0.1);
    }
    #charCanvas {
      font-family: "SF Mono", Menlo, Consolas, "Courier New", monospace;
      font-size: 16px;
      line-height: 1.2;
      white-space: pre;
      display: inline-block;
      user-select: none;
      outline: none;
      letter-spacing: 0;
    }
    .char-row {
      height: 1.2em;
      display: block;
    }
    .char-cell {
      display: inline-block;
      width: 1ch;
      text-align: center;
      vertical-align: top;
      color: var(--text-dark);
      border-radius: 2px;
      transition: all 0.15s ease;
      font-family: "SF Mono", Menlo, Consolas, "Courier New", monospace;
    }
    .char-cell.cursor {
      background: var(--ocean-light);
      box-shadow: 0 0 0 2px var(--ocean);
      transform: scale(1.05);
    }
    #cursorInfo {
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--text-light);
    }
    #outputPanel {
      margin-top: 16px;
    }
    #copyStatus {
      font-size: 0.85rem;
      margin-left: 8px;
      color: var(--ocean-dark);
      font-weight: 500;
    }
    @media (max-width: 800px) {
      #pixelCanvas {
        transform: scale(0.85);
        transform-origin: top left;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Banner editor for isle.chat</h1>
    <div class="sub">Design your channel banner with braille art or text</div>
  </div>

  <div class="layout">
    <div id="pixelPanel" class="panel">
      <div class="panel-title">Draw your banner (40×40 dots)</div>
      <div id="pixelCanvas"></div>
    </div>

    <div id="rightPanel" class="panel">
      <fieldset>
        <legend>Tools</legend>
        <div class="controls-row">
          <button id="clearBtn" class="secondary" type="button">Clear All</button>
          <button id="undoDrawBtn" class="secondary" type="button">↶ Undo</button>
          <button id="eraserBtn" class="secondary" type="button">Eraser: Off</button>
        </div>
        <div style="margin-top:10px;font-size:0.85rem;color:var(--text-light);">
          <strong>Draw:</strong> Click and drag on the dots • <strong>Type:</strong> Click a cell below and start typing
        </div>
      </fieldset>

      <div id="charCanvasWrapper">
        <div tabindex="0" id="charCanvas" aria-label="20 by 10 character canvas"></div>
        <div id="cursorInfo">Position: row <span id="cursorRow">1</span>, column <span id="cursorCol">1</span></div>
      </div>

      <fieldset id="outputPanel">
        <legend>Export</legend>
        <div class="controls-row">
          <button id="copyBtn" type="button">Copy Banner Text</button>
          <button id="copyCommandBtn" type="button">Copy /chan Command</button>
        </div>
        <div id="copyStatus" style="margin-top:8px;"></div>
      </fieldset>
    </div>
  </div>

  <script>
    (function () {
      const COLS = 20;
      const ROWS = 10;
      const DOT_COLS = COLS * 2; // 40
      const DOT_ROWS = ROWS * 4; // 40

      // Pixel grid: 40 x 40 booleans
      const pixels = [];
      for (let y = 0; y < DOT_ROWS; y++) {
        const row = [];
        for (let x = 0; x < DOT_COLS; x++) row.push(false);
        pixels.push(row);
      }

      // Character grid and text flags
      const chars = [];
      const isText = [];
      for (let r = 0; r < ROWS; r++) {
        const rowChars = [];
        const rowText = [];
        for (let c = 0; c < COLS; c++) {
          rowChars.push(' ');
          rowText.push(false);
        }
        chars.push(rowChars);
        isText.push(rowText);
      }

      let cursorRow = 0;
      let cursorCol = 0;

      const pixelCanvas = document.getElementById('pixelCanvas');
      const charCanvas = document.getElementById('charCanvas');
      const cursorRowSpan = document.getElementById('cursorRow');
      const cursorColSpan = document.getElementById('cursorCol');
      const copyBtn = document.getElementById('copyBtn');
      const copyCommandBtn = document.getElementById('copyCommandBtn');
      const copyStatus = document.getElementById('copyStatus');
      const clearBtn = document.getElementById('clearBtn');
      const undoDrawBtn = document.getElementById('undoDrawBtn');
      const eraserBtn = document.getElementById('eraserBtn');

      // Undo stack for drawing and eraser toggle
      const undoStack = [];
      const MAX_UNDO = 50;
      let eraserMode = false;

      function clonePixels() {
        const copy = [];
        for (let y = 0; y < DOT_ROWS; y++) {
          copy.push(pixels[y].slice());
        }
        return copy;
      }

      function pushUndoState() {
        undoStack.push(clonePixels());
        if (undoStack.length > MAX_UNDO) {
          undoStack.shift();
        }
      }

      function restorePixels(state) {
        for (let y = 0; y < DOT_ROWS; y++) {
          for (let x = 0; x < DOT_COLS; x++) {
            pixels[y][x] = state[y][x];
          }
        }
        for (let y = 0; y < DOT_ROWS; y++) {
          for (let x = 0; x < DOT_COLS; x++) {
            const idx = y * DOT_COLS + x;
            const el = pixelCanvas.children[idx];
            if (el) {
              el.classList.toggle('on', !!pixels[y][x]);
            }
          }
        }
        recomputeBrailleFromPixels();
      }

      function undoDrawing() {
        const state = undoStack.pop();
        if (!state) return;
        restorePixels(state);
      }

      // ---- Utility: braille conversion ----
      function brailleCharFromCell(r, c) {
        const baseY = r * 4;
        const baseX = c * 2;
        let bits = 0;
        function setBit(dot, dy, dx) {
          if (pixels[baseY + dy] && pixels[baseY + dy][baseX + dx]) {
            bits |= (1 << (dot - 1));
          }
        }
        // Braille dot layout:
        // (0,0)->1, (1,0)->2, (2,0)->3, (3,0)->7
        // (0,1)->4, (1,1)->5, (2,1)->6, (3,1)->8
        setBit(1, 0, 0);
        setBit(2, 1, 0);
        setBit(3, 2, 0);
        setBit(7, 3, 0);
        setBit(4, 0, 1);
        setBit(5, 1, 1);
        setBit(6, 2, 1);
        setBit(8, 3, 1);
        if (bits === 0) return ' ';
        return String.fromCharCode(0x2800 + bits);
      }

      function recomputeBrailleFromPixels() {
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (!isText[r][c]) {
              chars[r][c] = brailleCharFromCell(r, c);
            }
          }
        }
        renderCharCanvas();
      }

      function clearCellPixels(r, c) {
        const baseY = r * 4;
        const baseX = c * 2;
        for (let dy = 0; dy < 4; dy++) {
          for (let dx = 0; dx < 2; dx++) {
            // Use setPixel so the pixel DOM stays in sync, but skip recompute for performance.
            setPixel(baseY + dy, baseX + dx, false, true);
          }
        }
      }

      // ---- Pixel canvas UI ----
      let mouseDown = false;
      let paintValue = true;
      let isDragging = false; // used for touch undo grouping
      let lastDrawX = null;
      let lastDrawY = null;

      function setPixel(y, x, value, skipRecompute) {
        if (y < 0 || y >= DOT_ROWS || x < 0 || x >= DOT_COLS) return;

        // If we are drawing (turning a pixel on) over a cell that is currently text,
        // switch that cell back to braille-driven so the banner stays consistent.
        if (value) {
          const cellRow = Math.floor(y / 4);
          const cellCol = Math.floor(x / 2);
          if (cellRow >= 0 && cellRow < ROWS && cellCol >= 0 && cellCol < COLS) {
            if (isText[cellRow][cellCol]) {
              isText[cellRow][cellCol] = false;
            }
          }
        }

        pixels[y][x] = value;
        const idx = y * DOT_COLS + x;
        const el = pixelCanvas.children[idx];
        if (el) {
          el.classList.toggle('on', !!value);
        }
        if (!skipRecompute) {
          recomputeBrailleFromPixels();
        }
      }

      // Draw a continuous line between two pixel coordinates so fast drags don't skip dots.
      function drawLineBetweenPixels(x0, y0, x1, y1) {
        if (x0 === null || y0 === null) {
          setPixel(y1, x1, paintValue, true);
          return;
        }
        let dx = Math.abs(x1 - x0);
        let dy = Math.abs(y1 - y0);
        let sx = x0 < x1 ? 1 : -1;
        let sy = y0 < y1 ? 1 : -1;
        let err = dx - dy;

        while (true) {
          setPixel(y0, x0, paintValue, true);
          if (x0 === x1 && y0 === y1) break;
          const e2 = 2 * err;
          if (e2 > -dy) {
            err -= dy;
            x0 += sx;
          }
          if (e2 < dx) {
            err += dx;
            y0 += sy;
          }
        }
      }

      function buildPixelCanvas() {
        const frag = document.createDocumentFragment();
        for (let y = 0; y < DOT_ROWS; y++) {
          for (let x = 0; x < DOT_COLS; x++) {
            const div = document.createElement('div');
            div.className = 'pixel';
            div.dataset.x = String(x);
            div.dataset.y = String(y);
            frag.appendChild(div);
          }
        }
        pixelCanvas.appendChild(frag);
      }

      buildPixelCanvas();

      // Handle mouse/touch events on individual pixels
      pixelCanvas.addEventListener('mousedown', (e) => {
        const target = e.target;
        if (!target.classList.contains('pixel')) return;
        e.preventDefault();
        
        const x = Number(target.dataset.x);
        const y = Number(target.dataset.y);
        
        pushUndoState();
        
        mouseDown = true;
        // Drawing always sets pixels on; eraser always clears. Do not toggle based on existing state.
        paintValue = eraserMode ? false : true;
        lastDrawX = x;
        lastDrawY = y;
        setPixel(y, x, paintValue, true);
      });

      // Use mouseover so we get events for every pixel we pass across while dragging.
      pixelCanvas.addEventListener('mouseover', (e) => {
        if (!mouseDown) return;
        const target = e.target;
        if (!target.classList.contains('pixel')) return;
        
        const x = Number(target.dataset.x);
        const y = Number(target.dataset.y);
        drawLineBetweenPixels(lastDrawX, lastDrawY, x, y);
        lastDrawX = x;
        lastDrawY = y;
      });
      
      window.addEventListener('mouseup', () => {
        if (mouseDown) {
          mouseDown = false;
          lastDrawX = null;
          lastDrawY = null;
          recomputeBrailleFromPixels();
        }
      });

      // Touch support
      pixelCanvas.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        if (!target || !target.classList.contains('pixel')) return;
        e.preventDefault();
        
        const x = Number(target.dataset.x);
        const y = Number(target.dataset.y);
        
        if (!isDragging) {
          pushUndoState();
          isDragging = true;
        }
        
        mouseDown = true;
        // Same behavior as mouse: draw always on, eraser always off.
        paintValue = eraserMode ? false : true;
        lastDrawX = x;
        lastDrawY = y;
        setPixel(y, x, paintValue, true);
      });

      pixelCanvas.addEventListener('touchmove', (e) => {
        if (!mouseDown) return;
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        if (!target || !target.classList.contains('pixel')) return;
        e.preventDefault();
        
        const x = Number(target.dataset.x);
        const y = Number(target.dataset.y);
        drawLineBetweenPixels(lastDrawX, lastDrawY, x, y);
        lastDrawX = x;
        lastDrawY = y;
      });

      window.addEventListener('touchend', () => {
        if (mouseDown) {
          mouseDown = false;
          isDragging = false;
          lastDrawX = null;
          lastDrawY = null;
          recomputeBrailleFromPixels();
        }
      });

      // ---- Character canvas UI ----
      function renderCharCanvas() {
        charCanvas.innerHTML = '';
        const frag = document.createDocumentFragment();
        for (let r = 0; r < ROWS; r++) {
          const rowDiv = document.createElement('div');
          rowDiv.className = 'char-row';
          for (let c = 0; c < COLS; c++) {
            const span = document.createElement('span');
            span.className = 'char-cell';
            if (r === cursorRow && c === cursorCol) {
              span.classList.add('cursor');
            }
            span.dataset.row = String(r);
            span.dataset.col = String(c);
            const ch = chars[r][c] || ' ';
            span.textContent = ch;
            rowDiv.appendChild(span);
          }
          frag.appendChild(rowDiv);
        }
        charCanvas.appendChild(frag);
        updateCursorInfo();
      }

      function updateCursorInfo() {
        cursorRowSpan.textContent = String(cursorRow + 1);
        cursorColSpan.textContent = String(cursorCol + 1);
      }

      charCanvas.addEventListener('click', (e) => {
        const target = e.target;
        if (!target.classList.contains('char-cell')) return;
        cursorRow = Number(target.dataset.row);
        cursorCol = Number(target.dataset.col);
        renderCharCanvas();
        charCanvas.focus();
      });

      function moveCursor(dr, dc) {
        cursorRow = Math.max(0, Math.min(ROWS - 1, cursorRow + dr));
        cursorCol = Math.max(0, Math.min(COLS - 1, cursorCol + dc));
        renderCharCanvas();
      }

      function handleTextInputChar(ch) {
        if (!ch || ch.length !== 1) return;
        chars[cursorRow][cursorCol] = ch;
        isText[cursorRow][cursorCol] = true;
        clearCellPixels(cursorRow, cursorCol);
        renderCharCanvas();
        if (cursorCol < COLS - 1) {
          cursorCol++;
        } else if (cursorRow < ROWS - 1) {
          cursorRow++;
          cursorCol = 0;
        }
        renderCharCanvas();
      }

      function handleBackspace() {
        // If there is a character under the cursor, clear it in place first.
        if (chars[cursorRow][cursorCol] !== ' ') {
          chars[cursorRow][cursorCol] = ' ';
          isText[cursorRow][cursorCol] = true;
          clearCellPixels(cursorRow, cursorCol);
          renderCharCanvas();
          return;
        }

        // Otherwise, move back (with row wrap) and clear the previous cell.
        if (cursorCol > 0 || cursorRow > 0) {
          if (cursorCol > 0) {
            cursorCol--;
          } else {
            cursorRow--;
            cursorCol = COLS - 1;
          }
        }
        chars[cursorRow][cursorCol] = ' ';
        isText[cursorRow][cursorCol] = true;
        clearCellPixels(cursorRow, cursorCol);
        renderCharCanvas();
      }

      charCanvas.addEventListener('keydown', (e) => {
        const key = e.key;
        
        // Handle navigation and special keys
        switch (key) {
          case 'ArrowUp':
            e.preventDefault();
            moveCursor(-1, 0);
            return;
          case 'ArrowDown':
            e.preventDefault();
            moveCursor(1, 0);
            return;
          case 'ArrowLeft':
            e.preventDefault();
            moveCursor(0, -1);
            return;
          case 'ArrowRight':
            e.preventDefault();
            moveCursor(0, 1);
            return;
          case 'Backspace':
            e.preventDefault();
            handleBackspace();
            return;
          case 'Tab':
          case 'Enter':
            // ignore default navigation in canvas
            e.preventDefault();
            return;
        }
        
        // Allow all printable characters including those with shift (like #, @, etc)
        // Only block if it's a control/command key combo (not shift)
        if ((e.ctrlKey || e.metaKey) && !e.shiftKey) return;
        
        // Accept any single character (including shifted ones like #)
        if (key.length === 1) {
          e.preventDefault();
          handleTextInputChar(key);
        }
      });


      // ---- Clear ----
      function clearAll() {
        for (let y = 0; y < DOT_ROWS; y++) {
          for (let x = 0; x < DOT_COLS; x++) {
            pixels[y][x] = false;
          }
        }
        for (let i = 0; i < pixelCanvas.children.length; i++) {
          pixelCanvas.children[i].classList.remove('on');
        }
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            chars[r][c] = ' ';
            isText[r][c] = false;
          }
        }
        cursorRow = 0;
        cursorCol = 0;
        renderCharCanvas();
        copyStatus.textContent = '';
      }

      clearBtn.addEventListener('click', () => {
        clearAll();
      });

      if (undoDrawBtn) {
        undoDrawBtn.addEventListener('click', () => {
          undoDrawing();
        });
      }

      if (eraserBtn) {
        eraserBtn.addEventListener('click', () => {
          eraserMode = !eraserMode;
          eraserBtn.textContent = eraserMode ? 'Eraser: On' : 'Eraser: Off';
        });
      }

      window.addEventListener('keydown', (e) => {
        if ((e.metaKey || e.ctrlKey) && !e.shiftKey && e.key.toLowerCase() === 'z') {
          e.preventDefault();
          undoDrawing();
        }
      });

      // ---- Copy output ----
      function buildFlatString() {
        let s = '';
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const ch = chars[r][c];
            s += ch && ch.length === 1 ? ch : ' ';
          }
        }
        if (s.length < ROWS * COLS) {
          s = s.padEnd(ROWS * COLS, ' ');
        } else if (s.length > ROWS * COLS) {
          s = s.slice(0, ROWS * COLS);
        }
        return s;
      }

      async function copyTextToClipboard(text, successMessage) {
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
            copyStatus.textContent = successMessage;
          } else {
            const ta = document.createElement('textarea');
            ta.value = text;
            ta.style.position = 'fixed';
            ta.style.opacity = '0';
            document.body.appendChild(ta);
            ta.focus();
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
            copyStatus.textContent = successMessage + ' (fallback).';
          }
        } catch (err) {
          copyStatus.textContent = 'Copy failed; you can manually select and copy from the canvas.';
        }
        setTimeout(() => {
          copyStatus.textContent = '';
        }, 2500);
      }

      if (copyBtn) {
        copyBtn.addEventListener('click', async () => {
          const text = buildFlatString();
          await copyTextToClipboard(text, 'Copied 200 characters to clipboard.');
        });
      }

      if (copyCommandBtn) {
        copyCommandBtn.addEventListener('click', async () => {
          const banner = buildFlatString();
          const cmd = `/chan banner ${banner}`;
          await copyTextToClipboard(cmd, 'Copied /channel banner command to clipboard.');
        });
      }

      // Initial render
      renderCharCanvas();
    })();
  </script>
</body>
</html>
